const request = require('supertest');
const fs = require('fs');
const path = require('path');

// Mock the server
const app = require('../server');

describe('Server API Tests', () => {
  
  const uploadsDir = path.join(__dirname, '../public/uploads');
  
  beforeEach(() => {
    // Clean up uploads directory before each test
    if (fs.existsSync(uploadsDir)) {
      const files = fs.readdirSync(uploadsDir);
      files.forEach(file => {
        fs.unlinkSync(path.join(uploadsDir, file));
      });
    }
  });

  afterAll(() => {
    // Clean up after all tests
    if (fs.existsSync(uploadsDir)) {
      const files = fs.readdirSync(uploadsDir);
      files.forEach(file => {
        fs.unlinkSync(path.join(uploadsDir, file));
      });
    }
  });

  // Test 1: File upload with valid image
  test('should upload valid image successfully', async () => {
    const testImagePath = path.join(__dirname, 'test-images/valid-image.jpg');
    
    // Create a test image if it doesn't exist
    if (!fs.existsSync(path.dirname(testImagePath))) {
      fs.mkdirSync(path.dirname(testImagePath), { recursive: true });
    }
    
    // Create a simple test image (1x1 pixel JPEG)
    const jpegHeader = Buffer.from([
      0xFF, 0xD8, 0xFF, 0xE0, 0x00, 0x10, 0x4A, 0x46, 0x49, 0x46, 0x00, 0x01,
      0x01, 0x01, 0x00, 0x48, 0x00, 0x48, 0x00, 0x00, 0xFF, 0xDB, 0x00, 0x43,
      0x00, 0x08, 0x06, 0x06, 0x07, 0x06, 0x05, 0x08, 0x07, 0x07, 0x07, 0x09,
      0x09, 0x08, 0x0A, 0x0C, 0x14, 0x0D, 0x0C, 0x0B, 0x0B, 0x0C, 0x19, 0x12,
      0x13, 0x0F, 0x14, 0x1D, 0x1A, 0x1F, 0x1E, 0x1D, 0x1A, 0x1C, 0x1C, 0x20,
      0x24, 0x2E, 0x27, 0x20, 0x22, 0x2C, 0x23, 0x1C, 0x1C, 0x28, 0x37, 0x29,
      0x2C, 0x30, 0x31, 0x34, 0x34, 0x34, 0x1F, 0x27, 0x39, 0x3D, 0x38, 0x32,
      0x3C, 0x2E, 0x33, 0x34, 0x32, 0xFF, 0xC0, 0x00, 0x11, 0x08, 0x00, 0x01,
      0x00, 0x01, 0x01, 0x01, 0x11, 0x00, 0x02, 0x11, 0x01, 0x03, 0x11, 0x01,
      0xFF, 0xC4, 0x00, 0x14, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0xFF, 0xC4,
      0x00, 0x14, 0x10, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xDA, 0x00, 0x0C,
      0x03, 0x01, 0x00, 0x02, 0x11, 0x03, 0x11, 0x00, 0x3F, 0x00, 0x8F, 0xFF,
      0xD9
    ]);
    fs.writeFileSync(testImagePath, jpegHeader);

    const response = await request(app)
      .post('/api/upload')
      .attach('image', testImagePath)
      .set('x-session-id', 'test-session-123');

    expect(response.status).toBe(200);
    expect(response.body).toHaveProperty('success', true);
    expect(response.body).toHaveProperty('imageUrl');
    expect(response.body.imageUrl).toContain('uploads/');
    expect(response.body.imageUrl).toContain('test-session-123');
  });

  // Test 2: File upload with invalid format
  test('should reject invalid file format', async () => {
    const testFilePath = path.join(__dirname, 'test-images/invalid.txt');
    fs.writeFileSync(testFilePath, 'This is not an image');

    const response = await request(app)
      .post('/api/upload')
      .attach('image', testFilePath)
      .set('x-session-id', 'test-session-123');

    expect(response.status).toBe(400);
    expect(response.body).toHaveProperty('success', false);
    expect(response.body).toHaveProperty('error');
    expect(response.body.error).toContain('Invalid file format');
  });

  // Test 3: File upload without session ID
  test('should handle upload without session ID', async () => {
    const testImagePath = path.join(__dirname, 'test-images/valid-image.jpg');
    const jpegHeader = Buffer.from([
      0xFF, 0xD8, 0xFF, 0xE0, 0x00, 0x10, 0x4A, 0x46, 0x49, 0x46, 0x00, 0x01,
      0x01, 0x01, 0x00, 0x48, 0x00, 0x48, 0x00, 0x00, 0xFF, 0xDB, 0x00, 0x43,
      0x00, 0x08, 0x06, 0x06, 0x07, 0x06, 0x05, 0x08, 0x07, 0x07, 0x07, 0x09,
      0x09, 0x08, 0x0A, 0x0C, 0x14, 0x0D, 0x0C, 0x0B, 0x0B, 0x0C, 0x19, 0x12,
      0x13, 0x0F, 0x14, 0x1D, 0x1A, 0x1F, 0x1E, 0x1D, 0x1A, 0x1C, 0x1C, 0x20,
      0x24, 0x2E, 0x27, 0x20, 0x22, 0x2C, 0x23, 0x1C, 0x1C, 0x28, 0x37, 0x29,
      0x2C, 0x30, 0x31, 0x34, 0x34, 0x34, 0x1F, 0x27, 0x39, 0x3D, 0x38, 0x32,
      0x3C, 0x2E, 0x33, 0x34, 0x32, 0xFF, 0xC0, 0x00, 0x11, 0x08, 0x00, 0x01,
      0x00, 0x01, 0x01, 0x01, 0x11, 0x00, 0x02, 0x11, 0x01, 0x03, 0x11, 0x01,
      0xFF, 0xC4, 0x00, 0x14, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0xFF, 0xC4,
      0x00, 0x14, 0x10, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xDA, 0x00, 0x0C,
      0x03, 0x01, 0x00, 0x02, 0x11, 0x03, 0x11, 0x00, 0x3F, 0x00, 0x8F, 0xFF,
      0xD9
    ]);
    fs.writeFileSync(testImagePath, jpegHeader);

    const response = await request(app)
      .post('/api/upload')
      .attach('image', testImagePath);

    expect(response.status).toBe(200);
    expect(response.body).toHaveProperty('success', true);
    expect(response.body.imageUrl).toContain('nosession');
  });

  // Test 4: Palette generation with valid image
  test('should generate palettes for valid image', async () => {
    const testImagePath = path.join(__dirname, 'test-images/valid-image.jpg');
    const jpegHeader = Buffer.from([
      0xFF, 0xD8, 0xFF, 0xE0, 0x00, 0x10, 0x4A, 0x46, 0x49, 0x46, 0x00, 0x01,
      0x01, 0x01, 0x00, 0x48, 0x00, 0x48, 0x00, 0x00, 0xFF, 0xDB, 0x00, 0x43,
      0x00, 0x08, 0x06, 0x06, 0x07, 0x06, 0x05, 0x08, 0x07, 0x07, 0x07, 0x09,
      0x09, 0x08, 0x0A, 0x0C, 0x14, 0x0D, 0x0C, 0x0B, 0x0B, 0x0C, 0x19, 0x12,
      0x13, 0x0F, 0x14, 0x1D, 0x1A, 0x1F, 0x1E, 0x1D, 0x1A, 0x1C, 0x1C, 0x20,
      0x24, 0x2E, 0x27, 0x20, 0x22, 0x2C, 0x23, 0x1C, 0x1C, 0x28, 0x37, 0x29,
      0x2C, 0x30, 0x31, 0x34, 0x34, 0x34, 0x1F, 0x27, 0x39, 0x3D, 0x38, 0x32,
      0x3C, 0x2E, 0x33, 0x34, 0x32, 0xFF, 0xC0, 0x00, 0x11, 0x08, 0x00, 0x01,
      0x00, 0x01, 0x01, 0x01, 0x11, 0x00, 0x02, 0x11, 0x01, 0x03, 0x11, 0x01,
      0xFF, 0xC4, 0x00, 0x14, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0xFF, 0xC4,
      0x00, 0x14, 0x10, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xDA, 0x00, 0x0C,
      0x03, 0x01, 0x00, 0x02, 0x11, 0x03, 0x11, 0x00, 0x3F, 0x00, 0x8F, 0xFF,
      0xD9
    ]);
    fs.writeFileSync(testImagePath, jpegHeader);

    const response = await request(app)
      .post('/api/palettes')
      .send({ imageUrl: `/uploads/valid-image.jpg` });

    expect(response.status).toBe(200);
    expect(response.body).toHaveProperty('success', true);
    expect(response.body).toHaveProperty('palettes');
    expect(response.body.palettes).toHaveLength(3);
    
    // Check each palette has 5 colors
    response.body.palettes.forEach(palette => {
      expect(palette).toHaveProperty('colors');
      expect(palette.colors).toHaveLength(5);
    });
  });

  // Test 5: Palette generation with invalid image
  test('should handle palette generation for invalid image', async () => {
    const response = await request(app)
      .post('/api/palettes')
      .send({ imageUrl: '/uploads/nonexistent.jpg' });

    expect(response.status).toBe(200);
    expect(response.body).toHaveProperty('success', true);
    expect(response.body).toHaveProperty('palettes');
    expect(response.body.palettes).toHaveLength(3);
    
    // Should still return 3 palettes with fallback colors
    response.body.palettes.forEach(palette => {
      expect(palette).toHaveProperty('colors');
      expect(palette.colors).toHaveLength(5);
    });
  });

  // Test 6: Session cleanup
  test('should cleanup session files', async () => {
    // First upload a file with session ID
    const testImagePath = path.join(__dirname, 'test-images/cleanup-test.jpg');
    const jpegHeader = Buffer.from([
      0xFF, 0xD8, 0xFF, 0xE0, 0x00, 0x10, 0x4A, 0x46, 0x49, 0x46, 0x00, 0x01,
      0x01, 0x01, 0x00, 0x48, 0x00, 0x48, 0x00, 0x00, 0xFF, 0xDB, 0x00, 0x43,
      0x00, 0x08, 0x06, 0x06, 0x07, 0x06, 0x05, 0x08, 0x07, 0x07, 0x07, 0x09,
      0x09, 0x08, 0x0A, 0x0C, 0x14, 0x0D, 0x0C, 0x0B, 0x0B, 0x0C, 0x19, 0x12,
      0x13, 0x0F, 0x14, 0x1D, 0x1A, 0x1F, 0x1E, 0x1D, 0x1A, 0x1C, 0x1C, 0x20,
      0x24, 0x2E, 0x27, 0x20, 0x22, 0x2C, 0x23, 0x1C, 0x1C, 0x28, 0x37, 0x29,
      0x2C, 0x30, 0x31, 0x34, 0x34, 0x34, 0x1F, 0x27, 0x39, 0x3D, 0x38, 0x32,
      0x3C, 0x2E, 0x33, 0x34, 0x32, 0xFF, 0xC0, 0x00, 0x11, 0x08, 0x00, 0x01,
      0x00, 0x01, 0x01, 0x01, 0x11, 0x00, 0x02, 0x11, 0x01, 0x03, 0x11, 0x01,
      0xFF, 0xC4, 0x00, 0x14, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0xFF, 0xC4,
      0x00, 0x14, 0x10, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xDA, 0x00, 0x0C,
      0x03, 0x01, 0x00, 0x02, 0x11, 0x03, 0x11, 0x00, 0x3F, 0x00, 0x8F, 0xFF,
      0xD9
    ]);
    fs.writeFileSync(testImagePath, jpegHeader);

    const uploadResponse = await request(app)
      .post('/api/upload')
      .attach('image', testImagePath)
      .set('x-session-id', 'cleanup-test-session');

    expect(uploadResponse.status).toBe(200);

    // Check that file was uploaded
    const uploadedFiles = fs.readdirSync(uploadsDir);
    const sessionFiles = uploadedFiles.filter(file => file.includes('cleanup-test-session'));
    expect(sessionFiles.length).toBeGreaterThan(0);

    // Now cleanup the session
    const cleanupResponse = await request(app)
      .post('/api/cleanup-session')
      .send({ sessionId: 'cleanup-test-session' });

    expect(cleanupResponse.status).toBe(200);
    expect(cleanupResponse.body).toHaveProperty('success', true);
    expect(cleanupResponse.body.message).toContain('Cleanup completed');

    // Check that files were deleted
    const remainingFiles = fs.readdirSync(uploadsDir);
    const remainingSessionFiles = remainingFiles.filter(file => file.includes('cleanup-test-session'));
    expect(remainingSessionFiles.length).toBe(0);
  });

  // Test 7: Cleanup with invalid session ID
  test('should handle cleanup with invalid session ID', async () => {
    const response = await request(app)
      .post('/api/cleanup-session')
      .send({ sessionId: 'nonexistent-session' });

    expect(response.status).toBe(200);
    expect(response.body).toHaveProperty('success', true);
    expect(response.body.message).toContain('Cleanup completed');
    expect(response.body.message).toContain('0 files');
  });

  // Test 8: Cleanup without session ID
  test('should handle cleanup without session ID', async () => {
    const response = await request(app)
      .post('/api/cleanup-session');

    expect(response.status).toBe(200);
    expect(response.body).toHaveProperty('success', false);
    expect(response.body.message).toContain('No valid session ID provided');
  });

  // Test 9: Large file upload
  test('should reject files larger than 10MB', async () => {
    const largeFilePath = path.join(__dirname, 'test-images/large-file.jpg');
    
    // Create a file larger than 10MB
    const largeBuffer = Buffer.alloc(11 * 1024 * 1024); // 11MB
    fs.writeFileSync(largeFilePath, largeBuffer);

    const response = await request(app)
      .post('/api/upload')
      .attach('image', largeFilePath)
      .set('x-session-id', 'test-session-123');

    expect(response.status).toBe(400);
    expect(response.body).toHaveProperty('success', false);
    expect(response.body).toHaveProperty('error');
    expect(response.body.error).toContain('File too large');
  });

  // Test 10: Server health check
  test('should serve static files', async () => {
    const response = await request(app).get('/');
    expect(response.status).toBe(200);
  });

  // Test 11: API endpoint availability
  test('should have working API endpoints', async () => {
    const endpoints = [
      { method: 'POST', path: '/api/upload', description: 'File upload' },
      { method: 'POST', path: '/api/palettes', description: 'Palette generation' },
      { method: 'POST', path: '/api/cleanup-session', description: 'Session cleanup' }
    ];

    for (const endpoint of endpoints) {
      const response = await request(app)
        [endpoint.method.toLowerCase()](endpoint.path);
      
      // Should not return 404 (endpoint exists)
      expect(response.status).not.toBe(404);
    }
  });
});

console.log('✅ Server tests completed'); 